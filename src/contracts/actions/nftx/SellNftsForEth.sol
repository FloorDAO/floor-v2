// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';

import {IAction} from '@floor-interfaces/actions/Action.sol';
import {INFTXMarketplaceZap} from '@floor-interfaces/nftx/NFTXMarketplaceZap.sol';

/// If no tokens are claimable for the caller
error NoTokensProvided();

/**
 * This action allows us to batch sell ERC721 NFT tokens from the {Treasury}
 * into a specific NFTX vault.
 *
 * This uses the NFTX Marketplace Zap to facilitate the trade, allowing us to
 * specify a minimum amount of ETH to receive in return.
 */
contract NFTXSellNftsForEth is IAction {
    /// The NFTX Marketplace Zap contract
    INFTXMarketplaceZap public immutable marketplaceZap;

    /**
     * Store our required information to action a swap.
     *
     * @param asset Address of the token being liquidated
     * @param vaultId NFTX vault ID
     * @param tokenIds Array of token IDs owned by the {Treasury} to be liquidated
     * @param minEthOut The minimum amount of ETH to receive, otherwise the transaction
     * will be reverted to prevent front-running
     * @param path The generated exchange path
     */
    struct ActionRequest {
        address asset;
        uint vaultId;
        uint[] tokenIds;
        uint minEthOut;
        address[] path;
    }

    /**
     * We assign any variable contract addresses in our constructor, allowing us
     * to have multiple deployed actions if any parameters change.
     *
     * @param _marketplaceZap Address of the NFTX Marketplace Zap
     */
    constructor(address _marketplaceZap) {
        marketplaceZap = INFTXMarketplaceZap(_marketplaceZap);
    }

    /**
     * Sells our specified `tokenIds` from the NFTX vault collection to gain instant
     * ETH liquidity. If the transaction doesn't provide the specified required `minEthOut`
     * then the transaction will be reverted by NFTX.
     *
     * @param _request Packed bytes that will map to our `ActionRequest` struct
     *
     * @return uint The amount of ETH generated by the execution
     */
    function execute(bytes calldata _request) public payable returns (uint) {
        // Unpack the request bytes data into individual variables, as mapping it directly
        // to the struct is buggy due to memory -> storage array mapping.
        (address asset, uint vaultId, uint[] memory tokenIds, uint minEthOut, address[] memory path) =
            abi.decode(_request, (address, uint, uint[], uint, address[]));

        // Ensure that we have tokenIds sent
        uint length = tokenIds.length;
        if (length == 0) {
            revert NoTokensProvided();
        }

        // Loop through our tokens to transfer
        for (uint i; i < length;) {
            ERC721(request.asset).safeTransferFrom(msg.sender, address(this), tokenIds[i]);
            unchecked {
                ++i;
            }
        }

        // Now that the tokens are held in our contract we can approve the marketplace zap
        // to use them.
        ERC721(asset).setApprovalForAll(address(marketplaceZap), true);

        // Take a snapshot of our starting balance to calculate the end balance difference
        uint startBalance = address(msg.sender).balance;

        // Set up our swap parameters based on `execute` parameters
        marketplaceZap.mintAndSell721(vaultId, tokenIds, minEthOut, path, msg.sender);

        // We return just the amount of ETH generated in the swap, which will have
        // already been transferred to the {Treasury} during the swap itself.
        return address(msg.sender).balance - startBalance;
    }

    /**
     * Allows the contract to receive ERC721 tokens from our {Treasury}.
     */
    function onERC721Received(address, address, uint, bytes memory) public virtual returns (bytes4) {
        return this.onERC721Received.selector;
    }
}
