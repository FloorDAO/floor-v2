// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';

import {IAction} from '../../../interfaces/actions/Action.sol';
import {INFTXMarketplaceZap} from '../../../interfaces/nftx/NFTXMarketplaceZap.sol';

/// If no tokens are claimable for the caller
error NoTokensProvided();

/**
 * This action allows us to batch sell ERC721 NFT tokens from the {Treasury}
 * into a specific NFTX vault.
 *
 * This uses the NFTX Marketplace Zap to facilitate the trade, allowing us to
 * specify a minimum amount of ETH to receive in return.
 */
contract NFTXSellNFTForETH is IAction {
    /// The NFTX Marketplace Zap contract
    INFTXMarketplaceZap public immutable marketplaceZap;

    /// Mainnet WETH contract
    address public immutable WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    /// The {Treasury} contract that will fund the NFT tokens and will be
    /// the recipient of the swapped WETH.
    address public immutable treasury;

    /**
     * Store our required information to action a swap.
     *
     * @param asset Address of the token being liquidated
     * @param vaultId NFTX vault ID
     * @param tokenIds Array of token IDs owned by the {Treasury} to be liquidated
     * @param minEthOut The minimum amount of ETH to receive, otherwise the transaction
     * will be reverted to prevent front-running
     * @param path The generated exchange path
     */
    struct ActionRequest {
        address asset;
        uint vaultId;
        uint[] tokenIds;
        uint minEthOut;
        address[] path;
    }

    /**
     * We assign any variable contract addresses in our constructor, allowing us
     * to have multiple deployed actions if any parameters change.
     *
     * @param _marketplaceZap Address of the NFTX Marketplace Zap
     * @param _treasury Address of the Floor {Treasury} contract
     */
    constructor(address _marketplaceZap, address _treasury) {
        marketplaceZap = INFTXMarketplaceZap(_marketplaceZap);
        treasury = _treasury;
    }

    /**
     * Sells our specified `tokenIds` from the NFTX vault collection to gain instant
     * ETH liquidity. If the transaction doesn't provide the specified required `minEthOut`
     * then the transaction will be reverted by NFTX.
     *
     * @param _request Packed bytes that will map to our `ActionRequest` struct
     *
     * @return uint The amount of ETH generated by the execution
     */
    function execute(bytes calldata _request) public returns (uint) {
        // Unpack the request bytes data into individual variables, as mapping it directly
        // to the struct is buggy due to memory -> storage array mapping.
        (address asset, uint vaultId, uint[] memory tokenIds, uint minEthOut, address[] memory path) =
            abi.decode(_request, (address, uint, uint[], uint, address[]));

        // Now we can map our extracted data into our ActionRequest
        ActionRequest memory request = ActionRequest({asset: asset, vaultId: vaultId, tokenIds: tokenIds, minEthOut: minEthOut, path: path});

        // Ensure that we have tokenIds sent
        uint length = request.tokenIds.length;
        if (length == 0) {
            revert NoTokensProvided();
        }

        // Loop through our tokens to transfer
        for (uint i; i < length;) {
            ERC721(request.asset).safeTransferFrom(msg.sender, address(this), request.tokenIds[i]);
            unchecked {
                ++i;
            }
        }

        // Now that the tokens are held in our contract we can approve the marketplace zap
        // to use them.
        ERC721(request.asset).setApprovalForAll(address(marketplaceZap), true);

        // Take a snapshot of our starting balance to calculate the end balance difference
        uint startBalance = address(treasury).balance;

        // Set up our swap parameters based on `execute` parameters
        marketplaceZap.mintAndSell721(request.vaultId, request.tokenIds, request.minEthOut, request.path, treasury);

        // We return just the amount of WETH generated in the swap, which will have
        // already been transferred to the {Treasury} during the swap itself.
        return address(treasury).balance - startBalance;
    }

    /**
     * Allows the contract to receive ERC721 tokens from our {Treasury}.
     */
    function onERC721Received(address, address, uint, bytes memory) public virtual returns (bytes4) {
        return this.onERC721Received.selector;
    }
}
