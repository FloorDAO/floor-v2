// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

import "../../../interfaces/actions/Action.sol";
import "../../../interfaces/nftx/NFTXMarketplaceZap.sol";

/**
 * This action allows us to batch sell ERC721 NFT tokens from the {Treasury}
 * into a specific NFTX vault.
 *
 * This uses the NFTX Marketplace Zap to facilitate the trade, allowing us to
 * specify a minimum amount of ETH to receive in return.
 */
contract NFTXSellNFTForETH is IAction {
    /// The NFTX Marketplace Zap contract
    INFTXMarketplaceZap public immutable marketplaceZap;

    /// Mainnet WETH contract
    address public immutable WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    /// The {Treasury} contract that will fund the NFT tokens and will be
    /// the recipient of the swapped WETH.
    address public immutable treasury;

    /**
     * Store our required information to action a swap.
     *
     * @member asset Address of the token being liquidated
     * @member vaultId NFTX vault ID
     * @member tokenIds Array of token IDs owned by the {Treasury} to be liquidated
     * @member minEthOut The minimum amount of ETH to receive, otherwise the transaction
     * will be reverted to prevent front-running
     * @member path The generated exchange path
     */
    struct ActionRequest {
        address asset;
        uint256 vaultId;
        uint256[] tokenIds;
        uint256 minEthOut;
        address[] path;
    }

    /**
     * We assign any variable contract addresses in our constructor, allowing us
     * to have multiple deployed actions if any parameters change.
     *
     * @param _marketplaceZap Address of the NFTX Marketplace Zap
     * @param _treasury Address of the Floor {Treasury} contract
     */
    constructor(address _marketplaceZap, address _treasury) {
        marketplaceZap = INFTXMarketplaceZap(_marketplaceZap);
        treasury = _treasury;
    }

    /**
     * Sells our specified `tokenIds` from the NFTX vault collection to gain instant
     * ETH liquidity. If the transaction doesn't provide the specified required `minEthOut`
     * then the transaction will be reverted by NFTX.
     *
     * @param _request Packed bytes that will map to our `ActionRequest` struct
     *
     * @return uint The amount of ETH generated by the execution
     */
    function execute(bytes calldata _request) public returns (uint256) {
        // Unpack the request bytes data into our struct
        ActionRequest memory request = abi.decode(_request, (ActionRequest));

        // Ensure that we have tokenIds sent
        uint256 length = request.tokenIds.length;
        require(length != 0, "No tokens provided");

        // TODO: Expand support to 1155 and PUNKs
        for (uint256 i; i < length;) {
            ERC721(request.asset).safeTransferFrom(msg.sender, address(this), request.tokenIds[i]);
            unchecked {
                ++i;
            }
        }

        // Now that the tokens are held in our contract we can approve the marketplace zap
        // to use them.
        ERC721(request.asset).setApprovalForAll(address(marketplaceZap), true);

        // Take a snapshot of our starting balance to calculate the end balance difference
        uint256 startBalance = address(treasury).balance;

        // Set up our swap parameters based on `execute` parameters
        marketplaceZap.mintAndSell721(request.vaultId, request.tokenIds, request.minEthOut, request.path, treasury);

        // We return just the amount of WETH generated in the swap, which will have
        // already been transferred to the {Treasury} during the swap itself.
        return startBalance - address(treasury).balance;
    }

    /**
     * Allows the contract to receive ERC721 tokens from our {Treasury}.
     */
    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {
        return this.onERC721Received.selector;
    }
}
