// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import {AuthorityControl} from '@floor/authorities/AuthorityControl.sol';

import {IAction} from '@floor-interfaces/actions/Action.sol';
import {IVault} from '@floor-interfaces/vaults/Vault.sol';
import {IVaultFactory} from '@floor-interfaces/vaults/VaultFactory.sol';

/**
 * ..
 */
contract FloorWithdrawFromVault is AuthorityControl, IAction {

    /**
     * Store our required information to action a swap.
     *
     * ..
     */
    struct ActionRequest {
        address vaultFactory;
        uint vaultId;
        uint amount;
    }

    address public immutable treasury;

    /**
     * Set up our connection to the Treasury to ensure future calls only come from this
     * trusted source.
     *
     * @param _authority {AuthorityRegistry} contract address
     * @param _treasury ..
     */
    constructor(address _authority, address _treasury) AuthorityControl(_authority) {
        treasury = _treasury;
    }

    /**
     * Sells our specified `tokenIds` from the NFTX vault collection to gain instant
     * ETH liquidity. If the transaction doesn't provide the specified required `minEthOut`
     * then the transaction will be reverted by NFTX.
     *
     * @param _request Packed bytes that will map to our `ActionRequest` struct
     *
     * @return received The amount of ETH generated by the execution
     */
    function execute(bytes calldata _request) public payable onlyRole(TREASURY_MANAGER) returns (uint received) {
        // Unpack the request bytes data into our struct
        ActionRequest memory request = abi.decode(_request, (ActionRequest));

        // Ensure that we have an amount sent
        require(request.amount != 0, 'Invalid amount');

        IVaultFactory vaultFactory = IVaultFactory(request.vaultFactory);
        address vault = vaultFactory.vault(request.vaultId);

        // ..
        received = vaultFactory.withdraw(request.vaultId, request.amount);

        // Transfer the tokens to the {Treasury}
        IERC20(IVault(vault).collection()).transfer(treasury, received);
    }

}
