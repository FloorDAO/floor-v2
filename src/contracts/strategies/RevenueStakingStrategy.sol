// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {Initializable} from '@openzeppelin/contracts/proxy/utils/Initializable.sol';

import {CannotDepositZeroAmount, CannotWithdrawZeroAmount, NoRewardsAvailableToClaim} from '../utils/Errors.sol';

import {IBaseStrategy} from '@floor-interfaces/strategies/BaseStrategy.sol';

/// If the contract was unable to transfer tokens when registering the mint
/// @param recipient The recipient of the token transfer
/// @param amount The amount requested to be transferred
error UnableToTransferTokens(address recipient, uint amount);

/// If a caller of a protected function is not the parent vault
/// @param sender The address making the call
error SenderIsNotVault(address sender);

/**
 * Supports manual staking of "yield" from an authorised sender. This allows manual
 * yield management from external sources and products that cannot be strictly enforced
 * on-chain otherwise.
 *
 * The contract will extend the {BaseStrategy} to ensure it conforms to the required
 * logic and functionality.
 */
contract RevenueStakingStrategy is IBaseStrategy, Initializable {
    /// The human-readable name of the inventory strategy
    bytes32 public immutable name;

    /// The vault ID that the strategy is attached to
    uint public vaultId;

    /// The address of the vault the strategy is attached to
    address public vaultAddr;

    /// An array of tokens supported by the strategy
    address[] private _tokens;

    /**
     * This will return the internally tracked value of tokens that have been minted into
     * FLOOR by the {Treasury}.
     *
     * This value is stored in terms of ETH.
     */
    mapping (address => uint) public mintedRewards;

    /**
     * This will return the internally tracked value of tokens that have been claimed by
     * the strategy, regardless of if they have been minted into FLOOR.
     *
     * This value is stored in terms of the `yieldToken`.
     */
    mapping (address => uint) private lifetimeRewards;

    /**
     * Sets our strategy name.
     *
     * @param _name Human-readable name of the strategy
     */
    constructor(bytes32 _name) {
        name = _name;
    }

    /**
     * Sets up our contract variables.
     *
     * @param _vaultId Numeric ID of vault the strategy is attached to
     * @param _vaultAddr Address of vault the strategy is attached to
     * @param initData Encoded data to be decoded
     */
    function initialize(uint _vaultId, address _vaultAddr, bytes calldata initData) public initializer {
        (address[] memory validTokens) = abi.decode(initData, (address[]));

        vaultId = _vaultId;
        vaultAddr = _vaultAddr;
        _tokens = validTokens;
    }

    /**
     * Deposit underlying token or yield token to corresponding strategy.
     *
     * @param amount Amount of underlying token to deposit
     *
     * @return amount_ Amount of yield token returned from NFTX
     */
    function deposit(address token, uint amount) external onlyVault returns (uint amount_) {
        // Prevent users from trying to deposit nothing
        if (amount == 0) {
            revert CannotDepositZeroAmount();
        }

        // Transfer the underlying token from our caller
        IERC20(token).transferFrom(msg.sender, address(this), amount);

        // ..
        amount_ = IERC20(token).balanceOf(address(this));
        lifetimeRewards[token] += amount;

        // Emit our event to followers
        emit Harvest(token, amount);
    }

    /**
     * Withdraws an amount of our position from the strategy.
     */
    function withdraw(address /* token */, uint /* amount */) external onlyVault returns (uint) {
        //
    }

    /**
     * Harvest possible rewards from strategy.
     */
    function claimRewards() public view returns (address[] memory, uint[] memory) {
        uint length = _tokens.length;
        uint[] memory amount = new uint[](length);

        for (uint i; i < length;) {
            amount[i] = this.unmintedRewards(_tokens[i]);
             unchecked { ++i; }
        }

        return (_tokens, amount);
    }

    /**
     * The token amount of reward yield available to be claimed on the connected external
     * platform. Our `claimRewards` function will always extract the maximum yield, so this
     * could essentially return a boolean. However, I think it provides a nicer UX to
     * provide a proper amount and we can determine if it's financially beneficial to claim.
     *
     * This value is stored in terms of the `yieldToken`.
     *
     * @return The available rewards to be claimed
     */
    function rewardsAvailable(address /* token */) external pure returns (uint) {
        return 0;
    }

    /**
     * Total rewards generated by the strategy in all time. This is pure bragging rights.
     *
     * This value is stored in terms of the `yieldToken`.
     *
     * @return Total rewards generated by strategy
     */
    function totalRewardsGenerated(address token) external view returns (uint) {
        return lifetimeRewards[token];
    }

    /**
     * The amount of reward tokens generated by the strategy that is allocated to, but has not
     * yet been, minted into FLOOR tokens. This will be calculated by a combination of an
     * internally incremented tally of claimed rewards, as well as the returned value of
     * `rewardsAvailable` to determine pending rewards.
     *
     * This value is stored in terms of the `yieldToken`.
     *
     * @return Amount of unminted rewards held in the contract
     */
    function unmintedRewards(address token) external view returns (uint) {
        return IERC20(token).balanceOf(address(this));
    }

    /**
     * This is a call that will only be available for the {Treasury} to indicate that it
     * has minted FLOOR and that the internally stored `mintedRewards` integer should be
     * updated accordingly.
     *
     * @dev Only to be called by the {Treasury}
     *
     * @param amount Amount of token to be registered as minted
     */
    function registerMint(address recipient, address token, uint amount) external onlyVault {
        bool success = IERC20(token).transfer(recipient, amount);
        if (!success) revert UnableToTransferTokens(recipient, amount);

        unchecked {
            mintedRewards[token] += amount;
        }
    }

    /**
     * Returns an array of tokens that the strategy supports.
     */
    function tokens() external view returns (address[] memory) {
        return _tokens;
    }

    /**
     * Allows us to restrict calls to only be made by the connected vaultId.
     */
    modifier onlyVault() {
        if (msg.sender != vaultAddr) {
            revert SenderIsNotVault(msg.sender);
        }
        _;
    }
}
