// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import {ABDKMath64x64} from '@floor/forks/ABDKMath64x64.sol';

import {INftStakingBoostCalculator} from '@floor-interfaces/staking/NftStakingBoostCalculator.sol';

/**
 * Calculates the boost power generated from staked NFTs, factoring in the total
 * number of NFTs staked to give declining power when more tokens are staked.
 *
 * The formula for this is documented against the `calculate` function.
 */
contract NftStakingBoostCalculator is INftStakingBoostCalculator {

    /**
     * Performs the calculation to return the boost amount generated by the
     * staked tokens.
     *
     * In Excel / Sheets terms, this formula roughly equates to:
     * ```
     * (LOG(sweepPower, sweepTotal) * (SQRT(sweepTotal) - 1)) / sweepModifier
     * ```
     */
    function calculate(uint sweepPower, uint sweepTotal, uint sweepModifier) external pure returns (uint boost_) {
        // If we don't have any power, then our multiplier will just be 1
        if (sweepPower == 0) {
            return 1e9;
        }

        // Determine our logarithm base. When we only have one token, we get a zero result which
        // would lead to a zero division error. To avoid this, we ensure that we set a minimum
        // value of 1.
        if (sweepTotal == 1) {
            sweepModifier = (sweepModifier * 125) / 100;
            sweepTotal = 2;
        }

        uint x = ABDKMath64x64.toUInt(ABDKMath64x64.ln(ABDKMath64x64.fromUInt(sweepPower)) * 1e6) * 1e9;
        uint y = ABDKMath64x64.toUInt(ABDKMath64x64.ln(ABDKMath64x64.fromUInt(sweepTotal)) * 1e6);
        uint z = ABDKMath64x64.toUInt(ABDKMath64x64.sqrt(ABDKMath64x64.fromUInt(sweepTotal)) * 1e9) - 1e9;

        // Apply our modifiers to our calculations to determine our final multiplier
        boost_ = ((x / y) * z) / sweepModifier;
        if (boost_ < 1e9) {
            boost_ = 1e9;
        }
    }

}
